// bitmap_font.rs - Simple Bitmap Font for Pixel-Based Text Rendering
//
// This module provides a 5x7 pixel bitmap font for rendering text directly
// to pixel buffers. This is needed for layered windows with alpha transparency,
// where GDI text rendering doesn't work properly.
//
// Each character is 5 pixels wide and 7 pixels tall, stored as bit patterns.

use crate::constants::colors;

/// 5x7 bitmap font data (ASCII 32-122)
/// Each character is stored as 7 bytes, where each byte represents one row
/// and the lower 5 bits represent the pixel columns.
static FONT_DATA: &[u8] = &[
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // ! (33)
    0x04, 0x04, 0x04, 0x04, 0x00, 0x04, 0x00, // " (34)
    0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, // # (35)
    0x0A, 0x1F, 0x0A, 0x0A, 0x1F, 0x0A, 0x00, // $ (36)
    0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04, // % (37)
    0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03, // & (38)
    0x08, 0x14, 0x14, 0x08, 0x15, 0x12, 0x0D, // ' (39)
    0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, // ( (40)
    0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02, // ) (41)
    0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08, // * (42)
    0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00, // + (43)
    0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00, // , (44)
    0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x08, // - (45)
    0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, // . (46)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, // / (47)
    0x01, 0x01, 0x02, 0x04, 0x08, 0x10, 0x10, // 0-9 (48-57)
    0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E, // 0
    0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E, // 1
    0x0E, 0x11, 0x01, 0x06, 0x08, 0x10, 0x1F, // 2
    0x0E, 0x11, 0x01, 0x06, 0x01, 0x11, 0x0E, // 3
    0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02, // 4
    0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E, // 5
    0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x0E, // 6
    0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08, // 7
    0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E, // 8
    0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C, // 9
    // : (58)
    0x00, 0x00, 0x04, 0x00, 0x04, 0x00, 0x00, // ; (59)
    0x00, 0x00, 0x04, 0x00, 0x04, 0x04, 0x08, // < (60)
    0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02, // = (61)
    0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00, // > (62)
    0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08, // ? (63)
    0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04, // @ (64)
    0x0E, 0x11, 0x17, 0x15, 0x17, 0x10, 0x0E, // A-Z (65-90)
    0x0E, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11, // A
    0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E, // B
    0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E, // C
    0x1E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x1E, // D
    0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F, // E
    0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10, // F
    0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0E, // G
    0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11, // H
    0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E, // I
    0x01, 0x01, 0x01, 0x01, 0x01, 0x11, 0x0E, // J
    0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11, // K
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F, // L
    0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11, // M
    0x11, 0x19, 0x15, 0x13, 0x11, 0x11, 0x11, // N
    0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E, // O
    0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10, // P
    0x0E, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0D, // Q
    0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11, // R
    0x0E, 0x11, 0x10, 0x0E, 0x01, 0x11, 0x0E, // S
    0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, // T
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E, // U
    0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04, // V
    0x11, 0x11, 0x11, 0x15, 0x15, 0x1B, 0x11, // W
    0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11, // X
    0x11, 0x11, 0x0A, 0x04, 0x04, 0x04, 0x04, // Y
    0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F, // Z
    // [ (91)
    0x0E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0E, // \ (92)
    0x10, 0x10, 0x08, 0x04, 0x02, 0x01, 0x01, // ] (93)
    0x0E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0E, // ^ (94)
    0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 0x00, // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, // ` (96)
    0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, // a-z (97-122)
    0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F, // a
    0x10, 0x10, 0x1E, 0x11, 0x11, 0x11, 0x1E, // b
    0x00, 0x00, 0x0E, 0x11, 0x10, 0x11, 0x0E, // c
    0x01, 0x01, 0x0F, 0x11, 0x11, 0x11, 0x0F, // d
    0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E, // e
    0x06, 0x08, 0x1E, 0x08, 0x08, 0x08, 0x08, // f
    0x00, 0x00, 0x0F, 0x11, 0x0F, 0x01, 0x0E, // g
    0x10, 0x10, 0x1E, 0x11, 0x11, 0x11, 0x11, // h
    0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E, // i
    0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C, // j
    0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12, // k
    0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E, // l
    0x00, 0x00, 0x1A, 0x15, 0x15, 0x11, 0x11, // m
    0x00, 0x00, 0x1E, 0x11, 0x11, 0x11, 0x11, // n
    0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E, // o
    0x00, 0x00, 0x1E, 0x11, 0x1E, 0x10, 0x10, // p
    0x00, 0x00, 0x0F, 0x11, 0x0F, 0x01, 0x01, // q
    0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10, // r
    0x00, 0x00, 0x0E, 0x10, 0x0E, 0x01, 0x1E, // s
    0x08, 0x08, 0x1E, 0x08, 0x08, 0x09, 0x06, // t
    0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0D, // u
    0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04, // v
    0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A, // w
    0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11, // x
    0x00, 0x00, 0x11, 0x11, 0x0F, 0x01, 0x0E, // y
    0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F, // z
];

/// Font metrics
const CHAR_WIDTH: i32 = 5;
const CHAR_HEIGHT: i32 = 7;
const CHAR_SPACING: i32 = 2;

/// Canvas dimensions and pixel buffer
pub struct Canvas<'a> {
    pub pixels: &'a mut [u32],
    pub width: i32,
    pub height: i32,
}

/// Text rendering parameters
pub struct TextStyle {
    pub color: u32,
    pub scale: i32,
}

/// Draw a single character to the pixel buffer
/// Returns the width of the character drawn (including spacing)
fn draw_char(canvas: &mut Canvas, x: i32, y: i32, ch: char, style: &TextStyle) -> i32 {
    let char_index = if (' '..='z').contains(&ch) {
        (ch as usize) - 32
    } else {
        0 // Space for unknown characters
    };

    let font_offset = char_index * 7;

    for row in 0..CHAR_HEIGHT {
        if font_offset + row as usize >= FONT_DATA.len() {
            break;
        }
        let row_data = FONT_DATA[font_offset + row as usize];

        for col in 0..CHAR_WIDTH {
            if (row_data >> (4 - col)) & 1 == 1 {
                // Draw pixel with scaling
                for sy in 0..style.scale {
                    for sx in 0..style.scale {
                        let px = x + col * style.scale + sx;
                        let py = y + row * style.scale + sy;
                        if px >= 0 && px < canvas.width && py >= 0 && py < canvas.height {
                            let idx = (py * canvas.width + px) as usize;
                            if idx < canvas.pixels.len() {
                                canvas.pixels[idx] = style.color;
                            }
                        }
                    }
                }
            }
        }
    }

    (CHAR_WIDTH + CHAR_SPACING) * style.scale
}

/// Draw a line of text to the pixel buffer
pub fn draw_text(canvas: &mut Canvas, x: i32, y: i32, text: &str, style: &TextStyle) {
    let mut cursor_x = x;
    for ch in text.chars() {
        cursor_x += draw_char(canvas, cursor_x, y, ch, style);
    }
}

/// Calculate the width of a text string at a given scale
pub fn text_width(text: &str, scale: i32) -> i32 {
    text.len() as i32 * (CHAR_WIDTH + CHAR_SPACING) * scale
}

/// Draw centered help text for the selection overlay
pub fn draw_help_text(pixels: &mut [u32], width: i32, height: i32) {
    let mut canvas = Canvas {
        pixels,
        width,
        height,
    };

    // Help text content with color and scale
    let lines: &[(&str, u32, i32)] = &[
        ("RustFrame", colors::TEXT_BLUE, 2),
        ("", colors::TEXT_WHITE, 1),
        ("Drag borders to resize", colors::TEXT_GRAY, 1),
        ("Drag center to move", colors::TEXT_GRAY, 1),
        ("", colors::TEXT_WHITE, 1),
        ("ENTER - Start capture", colors::TEXT_WHITE, 1),
        ("ESC   - Exit", colors::TEXT_WHITE, 1),
        ("", colors::TEXT_WHITE, 1),
        ("C - Toggle cursor", colors::TEXT_GRAY, 1),
        ("B - Toggle border", colors::TEXT_GRAY, 1),
        ("S - Settings", colors::TEXT_GRAY, 1),
        ("", colors::TEXT_WHITE, 1),
        ("by Salih Cantekin", colors::TEXT_GRAY, 1),
    ];

    // Calculate line heights
    const LINE_HEIGHT: i32 = 16;
    const TITLE_HEIGHT: i32 = 28;
    const EMPTY_LINE_HEIGHT: i32 = 8;

    let total_height: i32 = lines
        .iter()
        .map(|(text, _, scale)| {
            if text.is_empty() {
                EMPTY_LINE_HEIGHT
            } else if *scale > 1 {
                TITLE_HEIGHT
            } else {
                LINE_HEIGHT
            }
        })
        .sum();

    let mut y = (height - total_height) / 2;

    for (text, color, scale) in lines {
        if text.is_empty() {
            y += EMPTY_LINE_HEIGHT;
            continue;
        }

        let style = TextStyle {
            color: *color,
            scale: *scale,
        };
        let text_w = text_width(text, *scale);
        let x = (width - text_w) / 2;

        draw_text(&mut canvas, x, y, text, &style);

        y += if *scale > 1 {
            TITLE_HEIGHT
        } else {
            LINE_HEIGHT
        };
    }
}
